#!/usr/bin/env Rscript

args <- commandArgs()
fname <- normalizePath(sub("--file=", "", args[grepl("--file=", args)]))
thisfile <- readLines(fname)
newfname <- paste0(tempdir(), "/", basename(fname))
writeLines(thisfile[-1:-which(thisfile == "q(\"no\")")], newfname)


library("optparse")
option_list = list(
	make_option(c("-l", "--layer2"), type="character", default="family", 
		help="layer 2", metavar="character"),
	make_option(c("-b", "--bitscore_thresh"), type="character", default="0", 
		help="bit score threshold", metavar="character")
); 
opt_parser = OptionParser(option_list=option_list);
opt = parse_args(opt_parser, positional_arguments=TRUE);
print(opt)
print(opt$args)

#####args = commandArgs(trailingOnly=TRUE)
#####print(normalizePath(args[1]))
#####args[1] = normalizePath(args[1])
opt$args[1] = normalizePath(opt$args[1])
print(opt$args)
print(opt$args[1])

#####outfile = paste(datafile, ".bitscoreGTE", bitscore_thresh, ".", layer2, ".pdf", sep = "")
#####output_file = paste(basename(fname),basename(args[1]),"html", sep=".")
#####output_file = paste(normalizePath(args[1]),"html", sep=".")
#####output_file = paste(args[1],"html", sep=".")

#output_file = paste(opt$args[1],"html", sep=".")
opt$output_base = paste( gsub(".csv","",opt$args[1]) , "bitscoreGTE", opt$options$bitscore_thresh, opt$options$layer2, sep=".")
opt$output_file = paste(opt$output_base, "html", sep=".")
print(opt$output_file)

#####rmarkdown::render(newfname, output_dir = dirname(fname), output_file = output_file )
rmarkdown::render(newfname, output_dir = dirname(opt$output_file), output_file = opt$output_file )

q("no")




---
title: "TEProf2_Heatmaps"
author: "Geno Guerra"
date: "2023-11-23"
output: html_document
---


```{r args}
args
```

```{r optargs}
opt$args
```

```{r args1}
args[1]
```


```{r setup, include=FALSE}
# Process the data 

#datafile = args[1]
datafile = opt$args[1]
```


```{r}
# Read in the datafile

df = read.csv(datafile, header=TRUE, sep = ",")
colnames(df)[which(colnames(df)=="name")]= "virus"
colnames(df)[which(colnames(df)=="accession")]= "protein"
```


```{r functions, echo = FALSE}
quantile_breaks <- function(xs, n) {
	breaks <- quantile(as.matrix(xs), probs = seq(0, 1, length.out = n))
	breaks[!duplicated(breaks)]
}
```


```{r}
library(pheatmap)  # RUN 
library(RColorBrewer)
dfa =cbind(df[,c(1:8)], df[, grep("_tumor", colnames(df))])
```


```{r}
dfmax =  apply(dfa[,-c(1:8)], 1, max, na.rm=TRUE)
```


```{r}
df0=dfa[which(dfmax >= opt$options$bitscore_thresh), ]
uv=levels(as.factor(df0$virus))
u2 = levels(as.factor(df0[,opt$options$layer2]))
```


```{r}
gaps =c()
# Need to reorder the data so that it is collected by group
ordered= c()
```


```{r}
for(j in c(1:length(u2))){
	uv2=levels(as.factor(df0$virus[which(df0[opt$options$layer2]== u2[j])]))

	for(k in c(1:length(uv2))){
		ordered = c(ordered,which(df0$virus ==uv2[k]) )
		#if(k!=length(uv2)){
		gaps=c(gaps,length(ordered))
		# }
	}

	# Change so only gaps appear according to the second layer. Not done yet. 
	#  gaps = c(gaps, gaps[length(gaps)], gaps[length(gaps)])
}  
```
  

```{r t1}
df1 = df0[as.integer(ordered),]
```


```{r t1a}
row_groups = df1$virus
mat_row = data.frame(group=row_groups)
rownames(mat_row)= df1$protein
annotation_rows = data.frame(virus = df1$virus, level2 = df1[,opt$options$layer2])
rownames(annotation_rows)= df1$protein
```


```{r t2}
colnames(annotation_rows) = c("virus", opt$options$layer2)
```

```{r t3}
df2=(df1[,-c(1:4)])
```


```{r t4}
row.names(df2)= df1$protein
#mat_colors <- list(group = rainbow(length(unique(row_groups))))
#names(mat_colors$group) <- unique(row_groups)
```


```{r t5}
mgaps = c(0, gaps)

#TCGA tumors only --------------------------
df3= df2[, grep("_tumor", colnames(df2))]
# -------------------------------------------

# Reorder rows so they are clustered within group. 
row.order = c()
for(i in c(1:(length(mgaps)-1))){
	if(mgaps[i+1]- mgaps[i] < 2){
		row.order = c(row.order,c((mgaps[i]+1):(mgaps[i+1])))
	}else{
		row.order = c(row.order, hclust(dist(df3[c((mgaps[i]+1):(mgaps[i+1])),]))$order + mgaps[i] )
	}
}
df4 = df3[row.order,]

#df4= df3[, grep("_normal", colnames(df3))]

dfb = as.matrix(df4)
#mat_breaks <- quantile_breaks(df4, 100)
# Alternative approach 
dfb=unlist(df4)
dfb=dfb[which(dfb >0)]
mat_breaks = seq(min(dfb), max(dfb), ceiling((max(dfb)-min(dfb))/10))
mat_breaks = c(0, mat_breaks)
colorpal= c("lightyellow", colorRampPalette(c("orange", "red", "darkred", "black"))(length(mat_breaks)-1))

mygaps= gaps	#c(0,gaps, 0,gaps, 0,gaps)
pheat.plot=pheatmap(df4,
	cluster_rows = F,
	cluster_cols = T,
	annotation_row = annotation_rows,
	col=colorpal,
	show_colnames = TRUE ,
	show_rownames = TRUE,
	gaps_row =mygaps,
	main = "",
	breaks=mat_breaks,
	fontsize_row = 4,
	fontsize_col=7,
	fontsize = 5)

#annotation_colors =mat_colors

save_pheatmap_pdf <- function(z, filename, width, height) {
	stopifnot(!missing(z))
	stopifnot(!missing(filename))
	pdf(filename, width=width, height=height)
	grid::grid.newpage()
	grid::grid.draw(z$gtable)
	dev.off()
}
##save_pheatmap_pdf(pheat.plot, output_file, 8, nrow(df4)/10+3)
##save_pheatmap_pdf(pheat.plot, paste(normalizePath(args[1]),"pdf", sep="."), 8, nrow(df4)/10+3)
save_pheatmap_pdf(pheat.plot, paste(opt$output_base,"pdf", sep="."), 8, nrow(df4)/10+3)

```


